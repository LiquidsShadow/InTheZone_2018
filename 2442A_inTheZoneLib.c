#pragma config(Sensor, in1,    mobileBaseLiftPot, sensorPotentiometer)
#pragma config(Sensor, in2,    mainLiftPot,    sensorPotentiometer)
#pragma config(Sensor, in3,    pincerPot,      sensorPotentiometer)
#pragma config(Sensor, dgtl9,  rightQuad,      sensorQuadEncoder)
#pragma config(Sensor, dgtl11, leftQuad,       sensorQuadEncoder)
#pragma config(Motor,  port1,           mobileBaseLiftLeft, tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           mobileBaseLiftRight, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           mainLiftLeft,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           mainLiftRight, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           driveRightFront, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           driveRightBack, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           driveLeftBack, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           driveLeftFront, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          pincers,       tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
Variable Naming Convention:

ML - main lift
MBL - mobile base lift
PINC - pincer
CONV - conversion
CTRL_POS - control position
U - up
D - down
O - open
C - close
*/

const float ML_CONV = 0.15;
const float MBL_CONV = 0.15;
const float PINC_CONV = 0.25;

enum CTRL_POS {MLU = 0, MLD = 0, MBLU = 0, MBLD = 0, PIN_O = 0, PIN_C = 0};

/*
Sets left drive motors to a power.
@param pwr -	a power
*/
void setLeftMotors(int pwr)
{
	motor[driveLeftBack] = pwr;
	motor[driveLeftFront] = pwr;
}
/*
Sets right drive motors to a power.
@param pwr - a power
*/
void setRightMotors(int pwr)
{
	motor[driveRightBack] = pwr;
	motor[driveRightFront] = pwr;
}
/*
Sets both right and left motors to a power
@param pwr - a power
*/
void setAllDriveMotors(int pwr)
{
	setLeftMotors(pwr);
	setRightMotors(pwr);
}
/*
Sets mobile base lift motor(s) to a power.
@param liftPower - a power.
*/
void setMobileBaseLiftPower(int pwr)
{
	motor[mobileBaseLiftLeft] = pwr;
	motor[mobileBaseLiftRight] = pwr;
}
/*
Sets main lift motor(s) to a power
@param liftPower - a power.
*/
void setMainLiftPower(int liftPower)
{
	motor[mainLiftLeft] = -liftPower;
	motor[mainLiftRight] = liftPower;
}
/*
Sets mobile base lift to a position while proportionally decreasing motor power as lift reaches desired position
@param liftPos - a position
*/
void setMobileBaseLiftToPos(int liftPos)
{
	int pwr = 0;

	do
	{
		// update variable & use temps
		int curr = SensorValue[mobileBaseLiftPot];
		int diff = curr - liftPos;
		pwr = (int) (MBL_CONV * diff);

		setMainLiftPower(pwr);
	}
	while (fabs(pwr) >= 5);
}
/*
Sets main lift to a position while proportionally decreasing motor power as lift reaches desired position
@param liftPos - a position
*/
void setMainLiftToPos(int liftPos)
{
	int pwr = 0;

	do
	{
		// update variables
		int curr = SensorValue[mainLiftPot];
		int diff = curr - liftPos;
		pwr = (int) (ML_CONV * diff);

		setMainLiftPower(pwr);
	}
	while (fabs(pwr) >= 5);
}
/*
Sets pincer motor(s) to a power
@param pincerPower - power to set the pincer motors to
*/
void setPincerPower(int pincerPower)
{
	motor[pincers] = pincerPower;
}
/*
Sets pincer to a position while decreasing motor power
@param pincerPos - a position
*/
void setPincersToPos(int pincerPos)
{
	int pwr = 0;

	do
	{
		// update variables
		int curr = SensorValue[mainLiftPot];
		int diff = curr - pincerPos;
		pwr = (int) (PINC_CONV * diff);

		setPincerPower(pwr);
	}
	while (fabs(pwr) >= 5);
}
/*
Runs user control
*/
void runUserControl()
{

	while(true)
	{
		// Joysticks
		int  rightJoy = vexRT[Ch2]; // right joystick
		int  leftJoy = vexRT[Ch3]; // left joystick
		// Buttons
		word btn8UP = vexRT[Btn8U]; // button raise mobile base lift
		word btn8DOWN = vexRT[Btn8D]; // button to lower mobile base lift
		// Triggers
		word rightTriggerUP = vexRT[Btn6U]; // trigger to raise main lift
		word rightTriggerDOWN = vexRT[Btn6D]; // trigger to lower main lift
		word leftTriggerUP = vexRT[Btn5U]; // trigger to open pincers
		word leftTriggerDOWN = vexRT[Btn5D]; // trigger to close pincers

		// Drive Control
		if(fabs(leftJoy) > 15) {
			setLeftMotors(leftJoy);
		}
		else {
			setLeftMotors(0);
		}

		if(fabs(rightJoy) > 15) {
			setRightMotors(rightJoy);
		}
		else {
			setRightMotors(0);
		}

		// Mobile base lift control -> change to proportional set...Pos() when ready; use "set..Power" for testing
		if(btn8UP == 1) {
			setMobileBaseLiftPower(127);
			//setMobileBaseLiftToPos(posMBLU);
		}
		else if(btn8DOWN == 1) {
			setMobileBaseLiftPower(-127);
			//setMobileBaseLiftToPos(posMBLD);
		}
		else {
			setMobileBaseLiftPower(0);
		}

		// Main lift control -> change to proportional set...Pos() when ready; use "set..Power" for testing

		if(rightTriggerUP == 1) {
			setMainLiftPower(-127);
			//setMainLiftToPos(posMLU);
		}
		else if(rightTriggerDOWN == 1) {
			setMainLiftPower(127);
			//setMainLiftToPos(posMLD);
		}
		else {
			setMainLiftPower(0);
		}

		// Pincer control -> change to proportional set...Pos() when ready;1 use "set..Power" for testing
		if(leftTriggerUP == 1) {
			setPincerPower(127);
			//setPincersToPos(posPinO);
		}
		else if(leftTriggerDOWN == 1) {
			setPincerPower(-127);
			//setPincersToPos(posPinC);
		}
		else {
			setPincerPower(0);
		}

	}
}

/*
Drives for a distance:
@param ticks - distance in encoder ticks
- If ticks < 0 => reverse
- If ticks > 0 => forwards
*/
void driveDist(int ticks)
{
	int maxPwr = 127; // will be proportionally decreased as robot approaches destination

	if (ticks / -1 > 0) // if ticks is negative => set negative motor power
		maxPwr *= -1;

	const int START_EN_L = SensorValue[leftQuad]; // left encoder start
	const int START_EN_R = SensorValue[rightQuad]; // right encoder start

	float distR = (START_EN_R + ticks) - SensorValue[rightQuad]; // distance to travel (right)
	float distL = (START_EN_L + ticks) - SensorValue[leftQuad]; // distance to travel (left)

	bool EnR_atDestination = fabs(distR) <= 10; // state of being at destination (right)
	bool EnL_atDestination = fabs(distL) <= 10; // state of being at destination (left)

	/*
	While the robot has not reached its destination:

	- update loop variables
	- proportionally decrease motor power
	*/
	do
	{
		if(!EnR_atDestination)
		{
			distR = (START_EN_R + ticks) - SensorValue[rightQuad];
			setRightMotors((distR/100) * maxPwr);
		}
		if(!EnL_atDestination)
		{
			distL = (START_EN_L + ticks) - SensorValue[leftQuad];
			setLeftMotors((distL/100) * maxPwr);
		}

		EnR_atDestination = fabs(distR) <= 10;
		EnL_atDestination = fabs(distL) <= 10;
	}
	while (!EnR_atDestination && !EnL_atDestination);

	setAllDriveMotors(0); // clean
}

/*
Runs programming skills
*/
void runProgrammingSkills()
{
}

/*
Runs autonomous
@param - string side
*/
void runAuton(string side)
{
	// can only start this once we have values for movement

	// - side independent -
	// drive forward for a certain amount
	// reverse for a portion of the forwards movement
	// - side dependent -
	// turn to line up robot w/ scoring zone
	// - side independent -
	// drive forward to move mobile base into scoring zone


}
