#pragma config(Sensor, in1,    leftClawPoten,  sensorPotentiometer)
#pragma config(Sensor, in2,    liftPoten,      sensorPotentiometer)
#pragma config(Sensor, in3,    rightClawPoten, sensorPotentiometer)
#pragma config(Sensor, dgtl1,  leftQuad,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightQuad,      sensorQuadEncoder)
#pragma config(Sensor, dgtl8,  redLED,         sensorLEDtoVCC)
#pragma config(Sensor, dgtl9,  yellowLED,      sensorLEDtoVCC)
#pragma config(Sensor, dgtl10, greenLED,       sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, leftPiston,     sensorDigitalOut)
#pragma config(Sensor, dgtl12, rightPiston,    sensorDigitalOut)
#pragma config(Motor,  port1,           claw2,         tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           test,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           driveLeftFront, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           driveLeftBack, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           driveRightFront, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           driveRightBack, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           liftLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           liftRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           forklift,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          claw,          tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)

#pragma competitionControl(Competition)


#define BCI_USE_TIMER
#define BCI_USE_POS_PID

#include "Vex_Competition_Includes.c"
#include "\InTheZoneLibrary.c"
#include "\BCI-master\BCI.h"
//#include "\BCI-master\drivingFunctions.c"
//#include "\BCI-master\turningFunctions.c"

int desired;
float kp;
task setLiftPos()
{
			clearTimer(T2);
			int err = desired - SensorValue[liftPoten];
			int power = 127;

			while(abs(err)>200 && time100(T2)<40) //adjust power of motors while error is outide of certain range, then set power to 0
			{
				err = desired - SensorValue[liftPoten];
				//power = (int) (((-1*(0.00152+2/3500)*(err) + (2+3))*127/5);
				power = (int) (err*127/4095*kp);
				setLiftPower(power);
				writeDebugStreamLine("Poten: %d, Power: %d, Error: %d", SensorValue[liftPoten], power,err);
			}
			setLiftPower(0);
}

void pre_auton()
{

}

void runBasicCompAuton(int zone)
{
	clearTimer(T1);

	//Drop mobile base lift, lift cone, and drive straight
	setForkliftPower(1);
	desired = 3700;
	startTask(setLiftPos); //lift up cone
	setLiftPower(-15);
	driveStraight(570,1,0); //drive to mobile goal
	wait10Msec(70);

	//pick up goal
	setForkliftPower(0); //pick up goal
	setLiftPower(0);
	wait10Msec(70);

	//drive back
	driveStraight(-400,1,0); //drive back
	wait10Msec(80);

	//turn around and drive straight
	turnDeg(200); //turn around
	if(zone == 5)
	{
		driveStraight(100,1,0);
	}
	else if(zone == 10)
	{
		driveStraight(150,1,0);
	}
	wait10Msec(1);

	//Score cone and goal
	setClawPower(127);
	desired = 3700;
	startTask(setLiftPos);//lift up cone
	setLiftPower(-15);
	setClawPower(0);
	setForkliftPower(1); //put down goal
	wait10Msec(40);

	driveStraight(-100,1,0); //back away to score
	setLiftPower(0); //stop killing motors
	writeDebugStreamLine("Time: %d", time100(T1));
}

task autonomous()
{
	string side = "right";
	runBasicCompAuton(10);
	//runProgSkills(side);
}

task usercontrol()
{
	enum PotenValues {BACK = 350, MATCHLOAD = 650, SCORE = 4095};
	enum kpValues {BackFromScore = 0, ScoreFromBack = 0, MatchloadFromScore = 0, ScoreFromMatchload = 0};
	SensorValue[rightQuad] = 0;
	SensorValue[leftQuad] = 0;
	char direction = 1; //controls direction
	bool btnEightRightPressed = false; //tracks if button was pressed


	while(true)
	{
		//testing led
	if(SensorValue[liftPoten]<1000)
	{
		sensorValue[redLED] = true;
		sensorValue[yellowLED] = false;
		sensorValue[greenLED] = false;
	}
	else if(SensorValue[liftPoten]<2500)
	{
		sensorValue[redLED] = false;
		sensorValue[yellowLED] = true;
		sensorValue[greenLED] = false;
	}
	else
	{
		sensorValue[redLED] = false;
		sensorValue[yellowLED] = false;
		sensorValue[greenLED] = true;
	}
		//Buttons and Joysticks
		int  rightJoy = vexRT[Ch2];
		int  leftJoy = vexRT[Ch3];
		word rightTriggerUp = vexRT[Btn6U]; //for up lift
		word rightTriggerDown = vexRT[Btn6D]; //for down lift
		word leftTriggerUp = vexRT[Btn5U]; //for pincer close
		word leftTriggerDown = vexRT[Btn5D]; //for pincer open
		word btnEightUp = vexRT[Btn8U];
		word btnEightDown = vexRT[Btn8D]; //for lift to set point
		word btnSevenD = vexRT[Btn7D]; //for lift to stationary goal
		word btnSevenUp = vexRT[Btn7U]; //for lift to match loads
		word btnEightRight = vexRT[Btn8R]; //for toggling reverse direction

		if(btnEightRight == 1 && !btnEightRightPressed){ //if button was pressed and was not already being pressed, change sign
			direction = -direction;
			btnEightRightPressed = true;
		}
		else if(btnEightRight == 0 && btnEightRightPressed) //if button is no longer being pressed, update bool
			btnEightRightPressed = false;

		//Drive Motors
		if(fabs(rightJoy) >= 15)
			if(direction==1)
			setRightMotors(rightJoy);
		else
			setLeftMotors(rightJoy);
		else
			if(direction==1)
			setRightMotors(0);
		else
			setLeftMotors(0);

		if(fabs(leftJoy) >= 15)
			if(direction==1)
			setLeftMotors(leftJoy);
		else
			setRightMotors(leftJoy);
		else
			if(direction==1)
			setLeftMotors(0);
		else
			setRightMotors(0);


		//Lift Motors
		if(rightTriggerUp == 1)
		{
			desired = SCORE;
			kp = 0.9;
			startTask(setLiftPos);
		}
		else if(rightTriggerDown == 1)
		{
			desired = BACK;
			kp = 0.88;
			startTask(setLiftPos);
		}
		//else if(btnSevenD==1)
		//{
		//	setLiftPos(2050,1.2);
		//}
		else if(btnSevenUp == 1)
		{
			desired = MATCHLOAD;
			kp = 0.9;
			startTask(setLiftPos);
			setClawPower(-80);
		}

		//Mobile Goal Base Lifters
		if(btnEightUp == 1)
			setForkliftPower(0);
		else if(btnEightDown == 1)
			setForkliftPower(1);

		//pincer
		if(leftTriggerDown == 1)
		{
			setClawPower(80);
		}
		else if(leftTriggerUp == 1)
		{
			setClawPower(-80);
		}
		else
		{
			setClawPower(0);
		}
	}
}
